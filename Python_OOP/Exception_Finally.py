# # Format of using: try - except:

# try:
#     #risky code: In this section our actual code logic will be added
#     x = int("abc")                  # This will throw a ValueError exception
# except ValueError as e:             
#     # Here ValueError is a Class in the Exception Class
#     # e will be the object of ValueError Class
#     # As we are creating an object of a Class, it will call its __init__ method automatically
#     print("Caught ValueError:", e) 
# # Here we are calling the object e

# # Output: Caught ValueError: invalid literal for int() with base 10: 'abc' 
#     # 1. Caught ValueError is the string passed in the print statement
#     # 2. invalid literal for int() with base 10: 'abc' - This message is printed as per the defined in the __init__ method of ValueError - Exception - BaseException 
#     # (This string is generated by the Compiler/ OS)

# # Without specifying an error: This is not a good practice
# try:
#     name = int("Atharva")
# except:
#     print("Something went wrong!")
    
    
# # Raising Exceptions manually for a particular scenario:
# # x = -1
# # if x < 0:
# #     raise ValueError("x must be non-negative")

# # Using try (actual block of code) - except (Exception) - else (Commands if no exception occurs) - finally (always runs, in case of exception or even if no exception occurs)
# try:
#     creating_exception = int("string")
# except ValueError as e:
#     print("Caught the ValueError Exception", e)
# else:
#     print("Exception did not occur")
# finally:
#     print("This logic will always run")



# # Defining a User Defined Exception and then raising the exception: Using the raise keyword
# class Accident(Exception):
#     def __init__(self, message):
#         self.message = message
        
#     def handle(self):
#         print("Accident Detected, Take Detour")

# # Using the Accident Exception:

# try:
#     raise Accident("Crash between 2 cars")              # When we tried to raise the Accident class, the __init__ method was called
#                                                         # __init__ method needs a message as an arguement
# except Accident as e:
#     e.handle()
    
# Practical use of try - except - else - finally:
import csv

def process_file():
    try:
        f = open('/Users/atharva/Documents/Learn/Dataset/Iris.csv')
        val = 10/0
    except FileNotFoundError as e:                              # As we are opening the file, we have the except for FileNotFoundError error, but nothing for 10/0
        print("Inside Except")
    except ZeroDivisionError as e:
        print("Handled the Type error")
    # Here if I execute this function, the program will be terminated and the file will be never closed and that will be result in waste of resources
    else:
       reader = csv.reader(f)
       for row in reader:
           print(row)
    finally:
        f.close()
        print("It is confirmed that the file is closed")
process_file()

# Following is the Output: Even when the 10/0 error is not handled, still the file is closed as we have f.close() in finally
""""
It is confirmed that the file is closed
Traceback (most recent call last):
  File "/Users/atharva/Documents/GitHub/Python_Pratice_DataScience/Python_OOP/Exception_Finally.py", line 75, in <module>
    process_file()
  File "/Users/atharva/Documents/GitHub/Python_Pratice_DataScience/Python_OOP/Exception_Finally.py", line 64, in process_file
    val = 10/0
          ~~^~
ZeroDivisionError: division by zero
"""